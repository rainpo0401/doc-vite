import{_ as n,c as a,o as e,a4 as s}from"./chunks/framework.DpC1ZpOZ.js";const m=JSON.parse('{"title":"ACN_AdvancedControlNetApply","description":"","frontmatter":{},"headers":[],"relativePath":"comfyui/ACN/ACN_AdvancedControlNetApply.md","filePath":"comfyui/ACN/ACN_AdvancedControlNetApply.md"}'),l={name:"comfyui/ACN/ACN_AdvancedControlNetApply.md"},t=s(`<h1 id="acn-advancedcontrolnetapply" tabindex="-1">ACN_AdvancedControlNetApply <a class="header-anchor" href="#acn-advancedcontrolnetapply" aria-label="Permalink to &quot;ACN_AdvancedControlNetApply&quot;">â€‹</a></h1><ul><li>Class name: AdvancedControlNetApply</li><li>Category: Adv-ControlNet ğŸ›‚ğŸ…ğŸ…’ğŸ…</li><li>Output node: False</li><li>Repo Ref: <a href="https://github.com/Kosinkadink/ComfyUI-Advanced-ControlNet.git" target="_blank" rel="noreferrer">https://github.com/Kosinkadink/ComfyUI-Advanced-ControlNet.git</a></li></ul><p>AdvancedControlNetApplyèŠ‚ç‚¹æ—¨åœ¨å°†æ§åˆ¶ä¿¡å·åº”ç”¨äºç¥ç»ç½‘ç»œæ¨¡å‹ã€‚å®ƒæ•´åˆäº†æ­£å‘å’Œè´Ÿå‘çš„è°ƒèŠ‚è¾“å…¥ä»¥åŠæ§åˆ¶ç½‘ç»œï¼Œä»¥å½±å“æ¨¡å‹çš„è¾“å‡ºã€‚è¯¥èŠ‚ç‚¹èƒ½å¤Ÿè°ƒæ•´æ§åˆ¶ä¿¡å·çš„å¼ºåº¦å’ŒèŒƒå›´ï¼Œç¡®ä¿å¯¹æ¨¡å‹è¡Œä¸ºè¿›è¡Œç²¾ç»†å’Œç²¾ç¡®çš„æ“æ§ã€‚</p><h1 id="input-types" tabindex="-1">Input types <a class="header-anchor" href="#input-types" aria-label="Permalink to &quot;Input types&quot;">â€‹</a></h1><h2 id="required" tabindex="-1">Required <a class="header-anchor" href="#required" aria-label="Permalink to &quot;Required&quot;">â€‹</a></h2><ul><li>positive <ul><li>æ­£å‘è°ƒèŠ‚è¾“å…¥å¯¹äºå¼•å¯¼æ¨¡å‹æœå‘æœŸæœ›çš„ç»“æœè‡³å…³é‡è¦ã€‚å®ƒä½œä¸ºæ¨¡å‹åœ¨ç”Ÿæˆè¿‡ç¨‹ä¸­å­¦ä¹ å’Œåº”ç”¨çš„å‚è€ƒã€‚</li><li>Comfy dtype: CONDITIONING</li><li>Python dtype: Union[Tensor, Iterable[Tuple[str, Dict]]]</li></ul></li><li>negative <ul><li>è´Ÿå‘è°ƒèŠ‚è¾“å…¥é€šè¿‡åœ¨ç”Ÿæˆè¿‡ç¨‹ä¸­æä¾›åº”æ’é™¤çš„ç¤ºä¾‹ï¼Œå¸®åŠ©æ¨¡å‹é¿å…ä¸å¸Œæœ›çš„è¾“å‡ºã€‚</li><li>Comfy dtype: CONDITIONING</li><li>Python dtype: Union[Tensor, Iterable[Tuple[str, Dict]]]</li></ul></li><li>control_net <ul><li>æ§åˆ¶ç½‘ç»œæ˜¯ä¸€ä¸ªå…³é”®ç»„ä»¶ï¼Œå®ƒå†³å®šäº†æ¨¡å‹çš„è¾“å‡ºå¦‚ä½•è¢«å½±å“ã€‚å®ƒç”¨äºå°†ç‰¹å®šçš„æ§åˆ¶ä¿¡å·åº”ç”¨äºæ¨¡å‹çš„ä¸åŒéƒ¨åˆ†ã€‚</li><li>Comfy dtype: CONTROL_NET</li><li>Python dtype: ControlBase</li></ul></li><li>image <ul><li>å›¾åƒè¾“å…¥ä¸ºæ¨¡å‹æä¾›è§†è§‰ä¸Šä¸‹æ–‡ï¼Œè¿™å¯¹äºç”Ÿæˆä¸æä¾›çš„è§†è§‰ä¿¡æ¯ä¸€è‡´çš„è¾“å‡ºè‡³å…³é‡è¦ã€‚</li><li>Comfy dtype: IMAGE</li><li>Python dtype: Tensor</li></ul></li><li>strength <ul><li>å¼ºåº¦å‚æ•°å†³å®šäº†æ–½åŠ åœ¨æ¨¡å‹ä¸Šçš„æ§åˆ¶ä¿¡å·çš„å¼ºåº¦ã€‚å®ƒå…è®¸å¾®è°ƒæ§åˆ¶ç½‘ç»œå¯¹æ¨¡å‹è¾“å‡ºçš„å½±å“ã€‚</li><li>Comfy dtype: FLOAT</li><li>Python dtype: float</li></ul></li><li>start_percent <ul><li>å¼€å§‹ç™¾åˆ†æ¯”å‚æ•°å®šä¹‰äº†æ§åˆ¶ä¿¡å·å½±å“çš„å¼€å§‹ç‚¹ï¼Œå…è®¸æ§åˆ¶æ§åˆ¶æ•ˆæœå¼€å§‹ç”Ÿæ•ˆçš„æ—¶é—´ã€‚</li><li>Comfy dtype: FLOAT</li><li>Python dtype: float</li></ul></li><li>end_percent <ul><li>ç»“æŸç™¾åˆ†æ¯”å‚æ•°æ ‡è®°äº†æ§åˆ¶ä¿¡å·å½±å“çš„ç»“æŸç‚¹ï¼Œä½¿æ§åˆ¶æ•ˆæœçš„æŒç»­æ—¶é—´å¯æ§ã€‚</li><li>Comfy dtype: FLOAT</li><li>Python dtype: float</li></ul></li></ul><h2 id="optional" tabindex="-1">Optional <a class="header-anchor" href="#optional" aria-label="Permalink to &quot;Optional&quot;">â€‹</a></h2><ul><li>mask_optional <ul><li>å¯é€‰çš„æ©ç è¾“å…¥å¯ä»¥ç”¨æ¥é€‰æ‹©æ€§åœ°å°†æ§åˆ¶ä¿¡å·åº”ç”¨äºæ¨¡å‹è¾“å‡ºçš„ç‰¹å®šåŒºåŸŸï¼Œæä¾›äº†ä¸€ç§å¾®è°ƒå±€éƒ¨æ§åˆ¶æ•ˆæœçš„æ‰‹æ®µã€‚</li><li>Comfy dtype: MASK</li><li>Python dtype: Optional[Tensor]</li></ul></li><li>model_optional <ul><li>model_optionalå‚æ•°å…è®¸æä¾›å¦ä¸€ä¸ªæ¨¡å‹ï¼Œè¯¥æ¨¡å‹å¯ä»¥ç”¨æ¥è¿›ä¸€æ­¥ç»†åŒ–åº”ç”¨äºä¸»æ¨¡å‹çš„æ§åˆ¶ä¿¡å·ã€‚</li><li>Comfy dtype: MODEL</li><li>Python dtype: Optional[ModelPatcher]</li></ul></li><li>timestep_kf <ul><li>æ—¶é—´æ­¥å…³é”®å¸§è¾“å…¥ç”¨äºå®šä¹‰æ§åˆ¶ä¿¡å·çš„æ—¶é—´ç»“æ„ï¼Œå…è®¸éšæ—¶é—´åŠ¨æ€æ§åˆ¶ã€‚</li><li>Comfy dtype: TIMESTEP_KEYFRAME</li><li>Python dtype: Optional[TimestepKeyframeGroup]</li></ul></li><li>latent_kf_override <ul><li>æ½œåœ¨å…³é”®å¸§è¦†ç›–å…è®¸å®šåˆ¶æ§åˆ¶ä¿¡å·å¯¹æ¨¡å‹æ½œåœ¨ç©ºé—´çš„å½±å“ï¼Œæä¾›äº†ä¸€ç§ç›´æ¥å½±å“æ¨¡å‹å†…éƒ¨è¡¨ç¤ºçš„æ–¹æ³•ã€‚</li><li>Comfy dtype: LATENT_KEYFRAME</li><li>Python dtype: Optional[LatentKeyframeGroup]</li></ul></li><li>weights_override <ul><li>æƒé‡è¦†ç›–å‚æ•°å…è®¸æŒ‡å®šæ§åˆ¶ç½‘ç»œçš„è‡ªå®šä¹‰æƒé‡ï¼Œå…è®¸å¯¹æ§åˆ¶ä¿¡å·çš„å¾®è°ƒè¿›è¡Œæ›´é«˜çº§åˆ«çš„æ§åˆ¶ã€‚</li><li>Comfy dtype: CONTROL_NET_WEIGHTS</li><li>Python dtype: Optional[ControlWeights]</li></ul></li></ul><h1 id="output-types" tabindex="-1">Output types <a class="header-anchor" href="#output-types" aria-label="Permalink to &quot;Output types&quot;">â€‹</a></h1><ul><li>positive <ul><li>æ­£å‘è¾“å‡ºä»£è¡¨äº†åº”ç”¨æ§åˆ¶ç½‘ç»œåçš„ä¿®æ”¹åçš„è°ƒèŠ‚è¾“å…¥ï¼Œåæ˜ äº†æ¨¡å‹å¯¹æœŸæœ›ç»“æœçš„ç†è§£ã€‚</li><li>Comfy dtype: CONDITIONING</li><li>Python dtype: Union[Tensor, Iterable[Tuple[str, Dict]]]</li></ul></li><li>negative <ul><li>è´Ÿå‘è¾“å‡ºåŒ…æ‹¬åŸºäºæ§åˆ¶ç½‘ç»œçš„å½±å“ï¼Œæ¨¡å‹åº”è¯¥é¿å…çš„ä¿®æ”¹åçš„è°ƒèŠ‚è¾“å…¥ã€‚</li><li>Comfy dtype: CONDITIONING</li><li>Python dtype: Union[Tensor, Iterable[Tuple[str, Dict]]]</li></ul></li><li>model_opt <ul><li>å¯é€‰çš„æ¨¡å‹è¾“å‡ºåœ¨åº”ç”¨æ§åˆ¶ç½‘ç»œæœŸé—´æä¾›äº†æ¨¡å‹çš„ä»»ä½•æ›´æ–°æˆ–æ”¹è¿›ã€‚</li><li>Comfy dtype: MODEL</li><li>Python dtype: Optional[ModelPatcher]</li></ul></li></ul><h1 id="usage-tips" tabindex="-1">Usage tips <a class="header-anchor" href="#usage-tips" aria-label="Permalink to &quot;Usage tips&quot;">â€‹</a></h1><ul><li>Infra type: GPU</li></ul><h1 id="source-code" tabindex="-1">Source code <a class="header-anchor" href="#source-code" aria-label="Permalink to &quot;Source code&quot;">â€‹</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>class AdvancedControlNetApply:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @classmethod</span></span>
<span class="line"><span>    def INPUT_TYPES(s):</span></span>
<span class="line"><span>        return {&#39;required&#39;: {&#39;positive&#39;: (&#39;CONDITIONING&#39;,), &#39;negative&#39;: (&#39;CONDITIONING&#39;,), &#39;control_net&#39;: (&#39;CONTROL_NET&#39;,), &#39;image&#39;: (&#39;IMAGE&#39;,), &#39;strength&#39;: (&#39;FLOAT&#39;, {&#39;default&#39;: 1.0, &#39;min&#39;: 0.0, &#39;max&#39;: 10.0, &#39;step&#39;: 0.01}), &#39;start_percent&#39;: (&#39;FLOAT&#39;, {&#39;default&#39;: 0.0, &#39;min&#39;: 0.0, &#39;max&#39;: 1.0, &#39;step&#39;: 0.001}), &#39;end_percent&#39;: (&#39;FLOAT&#39;, {&#39;default&#39;: 1.0, &#39;min&#39;: 0.0, &#39;max&#39;: 1.0, &#39;step&#39;: 0.001})}, &#39;optional&#39;: {&#39;mask_optional&#39;: (&#39;MASK&#39;,), &#39;timestep_kf&#39;: (&#39;TIMESTEP_KEYFRAME&#39;,), &#39;latent_kf_override&#39;: (&#39;LATENT_KEYFRAME&#39;,), &#39;weights_override&#39;: (&#39;CONTROL_NET_WEIGHTS&#39;,), &#39;model_optional&#39;: (&#39;MODEL&#39;,)}}</span></span>
<span class="line"><span>    RETURN_TYPES = (&#39;CONDITIONING&#39;, &#39;CONDITIONING&#39;, &#39;MODEL&#39;)</span></span>
<span class="line"><span>    RETURN_NAMES = (&#39;positive&#39;, &#39;negative&#39;, &#39;model_opt&#39;)</span></span>
<span class="line"><span>    FUNCTION = &#39;apply_controlnet&#39;</span></span>
<span class="line"><span>    CATEGORY = &#39;Adv-ControlNet ğŸ›‚ğŸ…ğŸ…’ğŸ…&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    def apply_controlnet(self, positive, negative, control_net, image, strength, start_percent, end_percent, mask_optional: Tensor=None, model_optional: ModelPatcher=None, timestep_kf: TimestepKeyframeGroup=None, latent_kf_override: LatentKeyframeGroup=None, weights_override: ControlWeights=None):</span></span>
<span class="line"><span>        if strength == 0:</span></span>
<span class="line"><span>            return (positive, negative, model_optional)</span></span>
<span class="line"><span>        if model_optional:</span></span>
<span class="line"><span>            model_optional = model_optional.clone()</span></span>
<span class="line"><span>        control_hint = image.movedim(-1, 1)</span></span>
<span class="line"><span>        cnets = {}</span></span>
<span class="line"><span>        out = []</span></span>
<span class="line"><span>        for conditioning in [positive, negative]:</span></span>
<span class="line"><span>            c = []</span></span>
<span class="line"><span>            for t in conditioning:</span></span>
<span class="line"><span>                d = t[1].copy()</span></span>
<span class="line"><span>                prev_cnet = d.get(&#39;control&#39;, None)</span></span>
<span class="line"><span>                if prev_cnet in cnets:</span></span>
<span class="line"><span>                    c_net = cnets[prev_cnet]</span></span>
<span class="line"><span>                else:</span></span>
<span class="line"><span>                    c_net = convert_to_advanced(control_net.copy()).set_cond_hint(control_hint, strength, (start_percent, end_percent))</span></span>
<span class="line"><span>                    if is_advanced_controlnet(c_net):</span></span>
<span class="line"><span>                        c_net.disarm()</span></span>
<span class="line"><span>                        if c_net.require_model:</span></span>
<span class="line"><span>                            if not model_optional:</span></span>
<span class="line"><span>                                raise Exception(f&quot;Type &#39;{type(c_net).__name__}&#39; requires model_optional input, but got None.&quot;)</span></span>
<span class="line"><span>                            c_net.patch_model(model=model_optional)</span></span>
<span class="line"><span>                        if timestep_kf is not None:</span></span>
<span class="line"><span>                            c_net.set_timestep_keyframes(timestep_kf)</span></span>
<span class="line"><span>                        if latent_kf_override is not None:</span></span>
<span class="line"><span>                            c_net.latent_keyframe_override = latent_kf_override</span></span>
<span class="line"><span>                        if weights_override is not None:</span></span>
<span class="line"><span>                            c_net.weights_override = weights_override</span></span>
<span class="line"><span>                        c_net.verify_all_weights()</span></span>
<span class="line"><span>                        if mask_optional is not None:</span></span>
<span class="line"><span>                            mask_optional = mask_optional.clone()</span></span>
<span class="line"><span>                            if len(mask_optional.shape) &lt; 3:</span></span>
<span class="line"><span>                                mask_optional = mask_optional.unsqueeze(0)</span></span>
<span class="line"><span>                            c_net.set_cond_hint_mask(mask_optional)</span></span>
<span class="line"><span>                    c_net.set_previous_controlnet(prev_cnet)</span></span>
<span class="line"><span>                    cnets[prev_cnet] = c_net</span></span>
<span class="line"><span>                d[&#39;control&#39;] = c_net</span></span>
<span class="line"><span>                d[&#39;control_apply_to_uncond&#39;] = False</span></span>
<span class="line"><span>                n = [t[0], d]</span></span>
<span class="line"><span>                c.append(n)</span></span>
<span class="line"><span>            out.append(c)</span></span>
<span class="line"><span>        return (out[0], out[1], model_optional)</span></span></code></pre></div>`,14),p=[t];function i(o,r,c,d,_,u){return e(),a("div",null,p)}const h=n(l,[["render",i]]);export{m as __pageData,h as default};
